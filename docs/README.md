# Общий алгоритм работы

![Общий алгоритм работы](./schemas/main.png)

## Ключевые понятия

### Симлинки

При работе системы используются симлинки - мягкие ссылки на реальные файлы. Симлинки необходимы для быстрой навигации по файлам и их агрегирования по папкам в зависимости от расширения. Принадлежность к батчу и образцу, результат первичного QC и т.д. - отражены в имени симлинка.

При обработке данных в пайплайны подставляются реальные пути к файлам, т.к. системы запуска пайплайнов (например, Nextflow) не могут работать с симлинками как исходными данными.

# Инициализация программы

При инициализации программа устанавливает связь с MongoDB, проверяет файловую систему и связь с менеджером задач Slurm.

## Связь с MongoDB

1. БД пингуется
2. Создаётся объект класса ConfigurableMongoDAO, являющийся обёрткой для работы с БД и всеми входящими в неё коллекциями

## Проверка файловой системы

1. Проверяются наличие и права всех папок, указанных в конфиге вотчдога
2. Проводится индексирование файлов, находящихся во входной папке; если файлы были проиндексированы ранее и их метаданные уже находятся в БД - проводится быстрая проверка сохранности и неизменности этих файлов
3. Формируются метаданные батчей и образцов на основе метаданных проиндексированных файлов

### Индексирование метаданных

#### Первичное индексирование

##### Файл

При рекурсивном обходе всех папок в папке исходных данных формируется список файлов. Для каждого файла затем формируется набор метаданных, содержащий:

* Абсолютный путь к файлу
* Батч
* id образца, к которому относится файл
* его расширение
* выходные данные команды stat, в т.ч. содержащие: размер файла, значения dev, ino и nlink.
* отпечаток, являющийся хэшем этих значений

В дальнейшем отпечаток используется для быстрой проверки неизменности файла.

##### Директория

Для каждой директории, содержащей исходные файлы, формируется свой набор метаданных, включающий список **только** исходных файлов, их размер, а также дочерние и родительскую директории.

##### Батч

На основе метаданных файла формируются метаданные батча. Важным дополнением является наличие метаданных о запуске, получаемых при парсинге pod5 файлов: даты секвенирования, идентификаторов ячейки и химии, а также версии поры и типа эксперимента. Если по каким-то причинам последние 2 значения остаются неизвестными, батч помечается как требующий курации (см. Курация батча).

##### Образец

Образец формируется на основе метаданных батчей, содержащих файлы, относящиеся к нему. При этом файлы из разных батчей группируются по типу эксперимента и версии поры.

Если время последней модификации батча отличается от текущего не более, чем на 10 минут,  батч получает debounce = True - в этом случае дальнейшая обработка батча, включая его добавление в мету образца, откладывается до переключения этого признака

Образец помечаеся как готовый к обработке в случае, если все батчи, к нему относящиеся, не требуют курации.

##### Курация батча

В батче неизвестная метадата (тип эксперимента / пора) => батч получает status='curation' и в unknowns добавляется название неизвестного параметра. Отсюда следует:

1. образец, имя которого есть в samples меты батча, тоже получает метку status='curation'
2. Все файлы, относящиеся к батчу, в образец не добавляются => метадата ДНК/РНК/пор не обновляется, в т.ч. общий размер
3. При добавлении метаданных в БД каждый батч с status='curation' добавляется в коллекцию **curations**. Добавляется следующая мета батча: name, final_summary, sequencing_summary, experiment_type, flow_cell, sequencing_kit, pore, created, modified, unknowns, meta_gathered_from, samples, refs_version.

Формируется объект CurationMeta.

После того, как он сформирован, поступает уведомление о его появлении (**!!!**). Далее идёт мониторинг версии pore_data.yaml, и в случае его обновления идёт повторная проверка на наличие нужных референсных данных. В случае неудачи обновлённая версия записывается в refs_version. В случае удачи (и пора, и молекула в pore_data.yaml):

1. Батч получает статус indexed
2. Файлы батча добавляются в ассоциированные с ним образцы
3. Батч удаляется из unknown_batches меты образца
4. Если unknown_batches образца пустой - образец получает статус 'indexed'

#### Повторное индексирование

##### Проверка наличия всех метаданных файлов ФС в БД после перезапуска

1. Система запрашивает в БД словарь "файл:отпечаток"
2. В ФС рекурсивно собирается список всех исходных файлов
3. Формируется 3 списка: файлы есть в ФС и БД; файлы только в ФС (неиндексированные); файлы только в БД (удалены/перемещены)

###### **Файлы есть в ФС и БД**

Проверяем, идентичен ли отпечаток; если нет, проверяем метадату. При изменении dev/ino/size создаётся батч-наследник; available старого файла переводится в false.

###### **Файл есть только в ФС**

Проверяем, есть ли батч в БД:

* да - создаётся батч-наследник;
* нет - создаём новый батч

###### **Файл есть только в БД**

Исходный файл перемещён/переименован/удалён - создаётся батч-наследник; available старого файла переводится в false.

###### Формирование батча-наследника

* создаётся новый батч с другим отпечатком
* в свойстве previous_version нового батча указывается старый батч, в свойстве changes указывается список отличий от старого батча
* в старом батче в свойстве next_version указывается отпечаток нового батча
* свойство status: в старом батче - 'outdated', в новом - 'indexed'/'curation' (в зависимости от полноты метаданных)

Также формируется и новый образец: в changes вносятся изменения, в previous_version записывается отпечаток старого образца, формируется новый отпечаток.

Все изменения записываются в коллекцию **changes**.

## Связь с планировщиком заданий

Для проверки работоспособности планировщику slurm посылается команда sinfo. В случае отсутствия ответа система завершает работу с ошибкой.

Далее формируется класс-обёртка для работы со slurm, позволяющий:

* формировать задания
* запускать их
* отслеживать их в режиме реального времени
* сохранять stdout, stderr и коды завершения
* осуществлять действия при завершении задания с ошибкой (перезапуск / оповещение об ошибке)

Информация о заданиях хранится в отдельной коллекции **tasks**. При инициализации планировщик запрашивает из этой коллекции информацию о задачах, имеющих статус "running". В случае, если демон slurm не возвращает информацию о задании, планировщик проверяет наличие файлов с заданными характеристиками, которые должны появиться в результате выполнения этого задания. При любом несоответствии статус задания получает значение "**fail**".

# Основной цикл работы

## Мониторинг

После инициализации система переходит в режим мониторинга. Мониторинг затрагивает ФС, БД и планировщик заданий. Каждое из событий, отслеживаемых программой, является триггером, запускающим определённый алгоритм действий.

### Мониторинг ФС

При мониторинге ФС отслеживаются только файлы, расширения которых совпадают с расширениями, указанными в параметре "extensions" в config.yaml.

Время события фиксируется и указывается в признаке "modified" батча.

#### Создание файла

При создании файла система собирает его метаданные и сличает с индексом в БД. В случае отсутствия записей о нём инициируется внесение данных файла в БД по стандартному протоколу (см. Первичное индексирование)

#### Модификация файла

При изменении файла (размера, положения в регистре диска, количестве жёстких ссылок) в БД создаётся новая запись о файле; старая запись получает статус "deprecated", как и записи батча и образца, к которым файл относится. В параметре changes указывается изменённый параметр, а также старые и новые значения. Формируется запись с новыми метаданными, которая включается в новые версии батча и образца (они, в свою очередь, аккумулируют в свои списки изменений все изменения файлов, к ним относящихся)

#### Перемещение файла

Если файл был перемещён, но его содержимое не было изменено, для него будет создана символьная ссылка, аналогичная старой. При этом в метаданных файла будут произведены следующие изменения:

* filepath - указан новый путь к файлу
* directory - указана новая директория файла
* если было затронуто имя файла, система определяет части имени, подвергшиеся изменению: в случае изменения частей имени файла, указывающих на его принадлежность к батчу/образцу будет инициирована модификация записей всех затронутых объектов. Также, если было изменено расширение файла, то он выпадает из множества файлов типа, к которому он относился ранее.

#### Удаление файла

При удалении запись файла в БД получает статус "deprecated", а для батча и образца, к которым относился файл, формируются новые записи; старые также помечаются как "deprecated".

### Мониторинг БД

При мониторинге БД:

* система определяет, какие образцы готовы к обработке тем или иным пайплайном, и формирует очереди обработки
* в случае появления объектов для курации система уведомляет об этом пользователя
* при изменении файлов, важных для курации, система запускает процесс курации.

### Мониторинг планировщика заданий

В настоящее время slurm не хранит в собственной БД результат выполнения заданий, поэтому каждое задание, поставленное планировщику, пингуется вотчдогом с заданной периодичностью (сам slurm хранит данные о задании не более 3 минут).

В случае изменения статуса задания система соответствующим образом изменяет статус обработки образца.

#### Формирование списка пайплайнов

Информация о пайплайнах для выполнения, включающая требования к образцам, находится в **pipeline_config.yaml**. Система периодически проверяет этот файл на наличие изменений, поэтому любые действия с пайплайнами могут применяться без перезагрузки системы.

Каждый пайплайн из **pipeline_config.yaml** трансформируется в объект класса Pipeline, имеющий атрибуты:

* имя пайплайна
* словарь условий, которые должны выполняться, чтобы образец был принят в обработку
* список входных файлов
* шаблон команды для выполнения
* инструкции по формированию готовой командной строки (какие данные и куда подставлять)
* список выходных файлов (проверяется их присутствие, в случае отсутствия - статус задания fail)
* количество выделяемых ресурсов для пайплайна, которые будут указаны планировщику заданий Slurm

В коллекции samples появляется свойство "pipeline_{название пайплайна}", отражающее статус его обработки (**not_started (reason)**/processing/ok/fail).

#### Постановка образца на обработку

Система периодически опрашивает БД на наличие образцов, подходящих для обработки тем или иным пайплайном. Для каждого образца, соответствующего заданным критериям (размер, успешная обработка другим пайплайном и др.) создаётся объект класса Task, атрибутами которого являются:

* название образца
* название пайплайна
* временная отметка постановки очереди в обработку
* временная отметка завершения обработки
* статус обработки slurm (и информация об ошибке в случае неудачной обработки)
* словарь с путями файлов, позволяющих проверить ход обработки
* статус проверки выходных файлов (**not_started (reason)**/ok/fail)

#### Завершение обработки

При завершении обработки запускается скрипт **db_filler.py**, запускающийся столько раз, сколько файлов должно быть спарсено для получения всего объёма результатов. Первый запуск скрипта осуществляется с аргумент(ом/ами) --set вида "basecalling_ubam:ubam_filepath". Аргумент set добавляет эту пару в результирующий YAML.

После парсинга всех файлов в коллекцию результатов БД вносятся данные из результирующего YAML, которые указаны в конфиге пайплайна.

## Завершение работы

### Сигналы завершения работы

# csp_nanopore_workflows

 Workflows for processing Nanopore reads with Nextflow implementation

#### to_do

**DAO должен мониторить доступ к БД!!!**

task_scheduler должен сортировать образцы на обработку по приоритетам (к примеру, сначала обрабатывать самые маленькие по размеру образцы)

add slurm options:

#SBATCH --time=1:00:00                # Maximum runtime (D-HH:MM:SS)

**-a** ,  **--array** =< *indexes* >

**--cpus-per-gpu** =< *ncpus* >

**-c** ,  **--cpus-per-task** =< *ncpus* > !!!!

**--kill-on-invalid-dep** =<yes|no>

--time

--begin

align:
    samtools_index: -@ 4 -> -@ params.threads

каждое задание имеет свою отдельную входную (касается nxf, который должен выполняться в отдельной папке) и выходную директорию

рестарт дропнутых заданий
