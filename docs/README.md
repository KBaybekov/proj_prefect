# Общий алгоритм работы

![Общий алгоритм работы](./schemas/main.png)

# Инициализация программы

При инициализации программа устанавливает связь с MongoDB, проверяет файловую систему и связь с менеджером задач Slurm.

## Связь с MongoDB

1. БД пингуется
2. Создаётся объект класса ConfigurableMongoDAO, являющийся обёрткой для работы с БД и всеми входящими в неё коллекциями

## Проверка файловой системы

1. Проверяются наличие и права всех папок, указанных в конфиге вотчдога
2. Проводится индексирование файлов, находящихся во входной папке; если файлы были проиндексированы ранее и их метаданные уже находятся в БД - проводится быстрая проверка сохранности и неизменности этих файлов
3. Формируются метаданные батчей и образцов на основе метаданных проиндексированных файлов

### Индексирование метаданных

#### Первичное индексирование

##### Файл

При рекурсивном обходе всех папок в папке исходных данных формируется список файлов. Для каждого файла затем формируется набор метаданных, содержащий:

* Абсолютный путь к файлу
* Батч
* id образца, к которому относится файл
* его расширение
* выходные данные команды stat, в т.ч. содержащие: размер файла, значения dev, ino и nlink.
* отпечаток, являющийся хэшем этих значений

В дальнейшем отпечаток используется для быстрой проверки неизменности файла.

##### Директория

Для каждой директории, содержащей исходные файлы, формируется свой набор метаданных, включающий список **только** исходных файлов, их размер, а также дочерние и родительскую директории.

##### Батч

На основе метаданных файла формируются метаданные батча. Важным дополнением является наличие метаданных о запуске, получаемых при парсинге pod5 файлов: даты секвенирования, идентификаторов ячейки и химии, а также версии поры и типа эксперимента. Если по каким-то причинам последние 2 значения остаются неизвестными, батч помечается как требующий курации (см. Курация батча).

##### Образец

Образец формируется на основе метаданных батчей, содержащих файлы, относящиеся к нему. При этом файлы из разных батчей группируются по типу эксперимента и версии поры.

Если время последней модификации батча отличается от текущего не более, чем на 10 минут,  батч получает debounce = True - в этом случае дальнейшая обработка батча, включая его добавление в мету образца, откладывается до переключения этого признака

Образец помечаеся как готовый к обработке в случае, если все батчи, к нему относящиеся, не требуют курации.

##### Курация батча

В батче неизвестная метадата (тип эксперимента / пора) => батч получает status='curation' и в unknowns добавляется название неизвестного параметра. Отсюда следует:

1. образец, имя которого есть в samples меты батча, тоже получает метку status='curation'
2. Все файлы, относящиеся к батчу, в образец не добавляются => метадата ДНК/РНК/пор не обновляется, в т.ч. общий размер
3. При добавлении метаданных в БД каждый батч с status='curation' добавляется в коллекцию **curations**. Добавляется следующая мета батча: name, final_summary, sequencing_summary, experiment_type, flow_cell, sequencing_kit, pore, created, modified, unknowns, meta_gathered_from, samples, refs_version.

Формируется объект CurationMeta.

После того, как он сформирован, поступает уведомление о его появлении (**!!!**). Далее идёт мониторинг версии pore_data.yaml, и в случае его обновления идёт повторная проверка на наличие нужных референсных данных. В случае неудачи обновлённая версия записывается в refs_version. В случае удачи (и пора, и молекула в pore_data.yaml):

1. Батч получает статус indexed
2. Файлы батча добавляются в ассоциированные с ним образцы
3. Батч удаляется из unknown_batches меты образца
4. Если unknown_batches образца пустой - образец получает статус 'indexed'

#### Повторное индексирование

##### Проверка наличия всех метаданных файлов ФС в БД после перезапуска

1. Система запрашивает в БД словарь "файл:отпечаток"
2. В ФС рекурсивно собирается список всех исходных файлов
3. Формируется 3 списка: файлы есть в ФС и БД; файлы только в ФС (неиндексированные); файлы только в БД (удалены/перемещены)

###### **Файлы есть в ФС и БД**

Проверяем, идентичен ли отпечаток; если нет, проверяем метадату. При изменении dev/ino/size создаётся батч-наследник; available старого файла переводится в false.

###### **Файл есть только в ФС**

Проверяем, есть ли батч в БД:

* да - создаётся батч-наследник;
* нет - создаём новый батч

###### **Файл есть только в БД**

Исходный файл перемещён/переименован/удалён - создаётся батч-наследник; available старого файла переводится в false.

###### Формирование батча-наследника

* создаётся новый батч с другим отпечатком
* в свойстве previous_version нового батча указывается старый батч, в свойстве changes указывается список отличий от старого батча
* в старом батче в свойстве next_version указывается отпечаток нового батча
* свойство status: в старом батче - 'outdated', в новом - 'indexed'/'curation' (в зависимости от полноты метаданных)

Также формируется и новый образец: в changes вносятся изменения, в previous_version записывается отпечаток старого образца, формируется новый отпечаток.

Все изменения записываются в коллекцию **changes**.

## Связь с планировщиком заданий

1. Планировщик пингуется
2. Создаётся объект класса ???, являющийся обёрткой для работы с планировщиком.

# Основной цикл работы

## Мониторинг

После инициализации система переходит в режим мониторинга. Мониторинг затрагивает ФС, БД и планировщик заданий. Каждое из событий, отслеживаемых программой, является триггером, запускающим определённый алгоритм действий.

### Мониторинг ФС

При мониторинге ФС отслеживаются только файлы, расширения которых совпадают с расширениями, указанными в параметре "extensions" в config.yaml.

Время события фиксируется и указывается в признаке "modified" батча.

#### Создание файла

При создании файла система собирает его метаданные и сличает с индексом в БД. В случае отсутствия записей о нём инициируется внесение данных файла в БД по стандартному протоколу (см. Первичное индексирование)

#### Модификация файла

При изменении файла (размера, положения в регистре диска, количестве жёстких ссылок) в БД создаётся новая запись о файле; старая запись получает статус "deprecated", как и записи батча и образца, к которым файл относится. В параметре changes указывается изменённый параметр, а также старые и новые значения. Формируется запись с новыми метаданными, которая включается в новые версии батча и образца (они, в свою очередь, аккумулируют в свои списки изменений все изменения файлов, к ним относящихся)

#### Перемещение файла

Если файл был перемещён, но его содержимое не было изменено, для него будет создана символьная ссылка, аналогичная старой. При этом в метаданных файла будут произведены следующие изменения:

* filepath - указан новый путь к файлу
* directory - указана новая директория файла
* если было затронуто имя файла, система определяет части имени, подвергшиеся изменению: в случае изменения частей имени файла, указывающих на его принадлежность к батчу/образцу будет инициирована модификация записей всех затронутых объектов. Также, если было изменено расширение файла, то он выпадает из множества файлов типа, к которому он относился ранее.

#### Удаление файла

При удалении запись файла в БД получает статус "deprecated", а для батча и образца, к которым относился файл, формируются новые записи.

### Мониторинг БД

При мониторинге БД:

* система определяет, какие образцы готовы к обработке тем или иным пайплайном, и формирует очереди обработки
* в случае появления объектов для курации система уведомляет об этом пользователя
* при изменении файлов, важных для курации, система запускает процесс курации.

### Мониторинг планировщика заданий

В текущей версии slurm не хранит в собственной БД результат выполнения заданий, поэтому каждое задание, поставленное планировщику, пингуется вотчдогом с заданной периодичностью.

В случае изменения статуса задания система соответствующим образом изменяет статус обработки образца.

## Обработка заданий

### Постановка образца на обработку

### Завершение обработки




# csp_nanopore_workflows

 Workflows for processing Nanopore reads with Nextflow implementation

#### to_do

add slurm options:

#SBATCH --time=1:00:00                # Maximum runtime (D-HH:MM:SS)

#SBATCH --mail-type=END               # Send email at job completion

#SBATCH --mail-user=your@email.com    # Email address for notifications

**-a** ,  **--array** =< *indexes* >

**--cpus-per-gpu** =< *ncpus* >

**-c** ,  **--cpus-per-task** =< *ncpus* > !!!!

**--kill-on-invalid-dep** =<yes|no>

--time

--begin

align:
    samtools_index: -@ 4 -> -@ params.threads

каждое задание имеет свою отдельную входную (касается nxf, который должен выполняться в отдельной папке) и выходную директорию

рестарт дропнутых заданий

 ADD RETRY OF TASK TO SLURM

crawler:

* доделать работу с ранее проиндексированными файлами: сравнение при инициалиазации с ранее сохранённой в БД метой, действия при добавлени/удалении/модификации файлов (см. index_source_files() в filesystem.py)

### Проверка наличия всех метаданных файлов ФС в БД после перезапуска

1. Система запрашивает в БД словарь "файл:отпечаток"
2. В ФС рекурсивно собирается список всех файлов с указанными расширениями
3. Формируется 3 списка: файлы есть в ФС и БД; файлы только в ФС (неиндексированные); файлы только в БД (удалены/перемещены)

**Файлы есть в ФС и БД**:

Проверяем, идентичен ли отпечаток; если нет, проверяем метадату. При изменении dev/ino/size батч, в который входит файл, помечается как dirty и уходит на **пересчёт**.

**Файл есть только в ФС**:

Размер файла > 0 ==> проверяем, есть ли батч в БД:

* да - батч, в который входит файл, помечается как dirty и уходит на **пересчёт**;
* нет - создаём новый батч

**Файл есть только в БД**:

Исходный файл перемещён/переименован/удалён - проверяем, .
