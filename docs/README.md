# Общий алгоритм работы

![Общий алгоритм работы](./schemas/main.png)

## Ключевые понятия

### Симлинки

При работе системы используются симлинки - мягкие ссылки на реальные файлы. Симлинки необходимы для быстрой навигации по файлам и их агрегирования по папкам в зависимости от расширения. Принадлежность к батчу и образцу, результат первичного QC и т.д. - отражены в имени симлинка.

При обработке данных в пайплайны подставляются реальные пути к файлам, т.к. системы запуска пайплайнов (например, Nextflow) не могут работать с симлинками как исходными данными.

# Инициализация программы

При инициализации программа устанавливает связь с MongoDB, проверяет файловую систему и связь с менеджером задач Slurm.

## Связь с MongoDB

1. БД пингуется
2. Создаётся объект класса ConfigurableMongoDAO, являющийся обёрткой для работы с БД и всеми входящими в неё коллекциями

## Проверка файловой системы

1. Проверяются наличие и права всех папок, указанных в конфиге вотчдога
2. Проводится индексирование файлов, находящихся во входной папке; если файлы были проиндексированы ранее и их метаданные уже находятся в БД - проводится быстрая проверка сохранности и неизменности этих файлов
3. Формируются метаданные батчей и образцов на основе метаданных проиндексированных файлов

### Индексирование метаданных

#### Первичное индексирование

##### Файл

При рекурсивном обходе всех папок в папке исходных данных формируется список файлов. Для каждого файла затем формируется набор метаданных, содержащий:

* Абсолютный путь к файлу
* Батч
* id образца, к которому относится файл
* его расширение
* выходные данные команды stat, в т.ч. содержащие: размер файла, значения dev, ino и nlink.
* отпечаток, являющийся хэшем этих значений

В дальнейшем отпечаток используется для быстрой проверки неизменности файла.

##### Директория

Для каждой директории, содержащей исходные файлы, формируется свой набор метаданных, включающий список **только** исходных файлов, их размер, а также дочерние и родительскую директории.

##### Батч

На основе метаданных файла формируются метаданные батча. Важным дополнением является наличие метаданных о запуске, получаемых при парсинге pod5 файлов: даты секвенирования, идентификаторов ячейки и химии, а также версии поры и типа эксперимента. Если по каким-то причинам последние 2 значения остаются неизвестными, батч помечается как требующий курации (см. Курация батча).

##### Образец

Образец формируется на основе метаданных батчей, содержащих файлы, относящиеся к нему. При этом файлы из разных батчей группируются по типу эксперимента и версии поры.

Если время последней модификации батча отличается от текущего не более, чем на 10 минут,  батч получает debounce = True - в этом случае дальнейшая обработка батча, включая его добавление в мету образца, откладывается до переключения этого признака

Образец помечаеся как готовый к обработке в случае, если все батчи, к нему относящиеся, не требуют курации.

##### Курация батча

В батче неизвестная метадата (тип эксперимента / пора) => батч получает status='curation' и в unknowns добавляется название неизвестного параметра. Отсюда следует:

1. образец, имя которого есть в samples меты батча, тоже получает метку status='curation'
2. Все файлы, относящиеся к батчу, в образец не добавляются => метадата ДНК/РНК/пор не обновляется, в т.ч. общий размер
3. При добавлении метаданных в БД каждый батч с status='curation' добавляется в коллекцию **curations**. Добавляется следующая мета батча: name, final_summary, sequencing_summary, experiment_type, flow_cell, sequencing_kit, pore, created, modified, unknowns, meta_gathered_from, samples, refs_version.

Формируется объект CurationMeta.

После того, как он сформирован, поступает уведомление о его появлении (**!!!**). Далее идёт мониторинг версии pore_data.yaml, и в случае его обновления идёт повторная проверка на наличие нужных референсных данных. В случае неудачи обновлённая версия записывается в refs_version. В случае удачи (и пора, и молекула в pore_data.yaml):

1. Батч получает статус indexed
2. Файлы батча добавляются в ассоциированные с ним образцы
3. Батч удаляется из unknown_batches меты образца
4. Если unknown_batches образца пустой - образец получает статус 'indexed'

#### Повторное индексирование

##### Проверка наличия всех метаданных файлов ФС в БД после перезапуска

1. Система запрашивает в БД словарь "файл:отпечаток"
2. В ФС рекурсивно собирается список всех исходных файлов
3. Формируется 3 списка: файлы есть в ФС и БД; файлы только в ФС (неиндексированные); файлы только в БД (удалены/перемещены)

###### **Файлы есть в ФС и БД**

Проверяем, идентичен ли отпечаток; если нет, проверяем метадату. При изменении dev/ino/size создаётся батч-наследник; available старого файла переводится в false.

###### **Файл есть только в ФС**

Проверяем, есть ли батч в БД:

* да - создаётся батч-наследник;
* нет - создаём новый батч

###### **Файл есть только в БД**

Исходный файл перемещён/переименован/удалён - создаётся батч-наследник; available старого файла переводится в false.

###### Формирование батча-наследника

* создаётся новый батч с другим отпечатком
* в свойстве previous_version нового батча указывается старый батч, в свойстве changes указывается список отличий от старого батча
* в старом батче в свойстве next_version указывается отпечаток нового батча
* свойство status: в старом батче - 'outdated', в новом - 'indexed'/'curation' (в зависимости от полноты метаданных)

Также формируется и новый образец: в changes вносятся изменения, в previous_version записывается отпечаток старого образца, формируется новый отпечаток.

Все изменения записываются в коллекцию **changes**.

## Связь с планировщиком заданий

Для проверки работоспособности планировщику проверяется, есть ли в $PATH оболочки **sbatch**. В случае отсутствия утилиты система завершает работу с ошибкой.

Далее формируется класс-обёртка для работы со slurm, позволяющий:

* формировать задания на основе метаданных образцов, хранящихся в БД, и конфигураций пайплайнов
* запускать их в планировщике заданий Slurm
* отслеживать их состояние
* сохранять записи о результатах выполнения заданий в БД
* сохранять stdout, stderr и коды завершения головной задачи
* осуществлять действия при завершении задания с ошибкой (перезапуск / оповещение об ошибке)

Информация о заданиях хранится в отдельной коллекции **tasks**. При инициализации планировщик запрашивает из этой коллекции информацию о задачах, имеющих статус "running". В случае, если демон slurm не возвращает информацию о задании, планировщик проверяет наличие файлов с заданными характеристиками, которые должны появиться в результате выполнения этого задания. При любом несоответствии статус задания получает значение "**fail**".

# Основной цикл работы

## Мониторинг

После инициализации система переходит в режим мониторинга. Мониторинг затрагивает ФС, БД и планировщик заданий. Каждое из событий, отслеживаемых программой, является триггером, запускающим определённый алгоритм действий.

### Мониторинг ФС

При мониторинге ФС отслеживаются только файлы, расширения которых совпадают с расширениями, указанными в параметре "extensions" в config.yaml.

Время события фиксируется и указывается в признаке "modified" батча.

#### Создание файла

При создании файла система собирает его метаданные и сличает с индексом в БД. В случае отсутствия записей о нём инициируется внесение данных файла в БД по стандартному протоколу (см. Первичное индексирование)

#### Модификация файла

При изменении файла (размера, положения в регистре диска, количестве жёстких ссылок) в БД создаётся новая запись о файле; старая запись получает статус "deprecated", как и записи батча и образца, к которым файл относится. В параметре changes указывается изменённый параметр, а также старые и новые значения. Формируется запись с новыми метаданными, которая включается в новые версии батча и образца (они, в свою очередь, аккумулируют в свои списки изменений все изменения файлов, к ним относящихся)

#### Перемещение файла

Если файл был перемещён, но его содержимое не было изменено, для него будет создана символьная ссылка, аналогичная старой. При этом в метаданных файла будут произведены следующие изменения:

* filepath - указан новый путь к файлу
* directory - указана новая директория файла
* если было затронуто имя файла, система определяет части имени, подвергшиеся изменению: в случае изменения частей имени файла, указывающих на его принадлежность к батчу/образцу будет инициирована модификация записей всех затронутых объектов. Также, если было изменено расширение файла, то он выпадает из множества файлов типа, к которому он относился ранее.

#### Удаление файла

При удалении запись файла в БД получает статус "deprecated", а для батча и образца, к которым относился файл, формируются новые записи; старые также помечаются как "deprecated".

### Мониторинг БД

При мониторинге БД система периодически пингует БД

### Мониторинг планировщика заданий

Каждое задание, поставленное планировщику, пингуется вотчдогом с заданной периодичностью. Информация о заданиях собирается через squeue.

В случае изменения статуса задания система соответствующим образом изменяет статус обработки образца.

#### Формирование списка пайплайнов

Каждый пайплайн трансформируется в объект класса Pipeline, имеющий атрибуты:

* имя
* версия
* шейпер (Python-файл, содержащий методы, позволяющие формировать входные и выходные данные для данного пайплайна)
* список фильтров БД, применение которых позволит получить список образцов, подходящих для обработки
* тип сортировки, который следует использовать для заданий с пайплайном данного типа (зависит от конфигурации кластера)
* (опц.) словарь опций для команды **sbatch**
* (опц.) словарь переменных, специфичных для пайплайна Nextflow
* (опц.) словарь переменных среды
* максимальное время выполнения задания
* шаблон команды Nextflow для выполнения
* список входных файлов, разбитых по смысловым группам (напр. QC); содержат указание на источник файлов и маски, которые необходимо использовать для поиска этих файлов; также содержит требования к файлам (существуют, не пустые и т.д.)
* список выходных файлов, разбитых по смысловым группам (напр. QC); каждая группа содержит подгруппы, представляющие собой набор файлов одного типа, и маски для их поиска

В атрибуте samples.tasks появляется запись о пайплайне, включающее id задания и статус его обработки.

#### Постановка образца на обработку

Система периодически опрашивает БД на наличие образцов, подходящих для обработки тем или иным пайплайном. Для каждого образца, соответствующего заданным критериям (размер, успешная обработка другим пайплайном и др.) создаётся задание, атрибутами которого являются:

* id задания
* данные пайплайна
* данные образца
* данные его результатов обработки
* статус задания
* тип сортировки, наследуемый у пайплайна
* словарь с данными, касающимися задания (входные/выходные данные, директории, файлы потоков головного задания Slurm и т.д.)
* временная отметка постановки очереди в обработку
* временная отметка завершения обработки
* временная отметка последнего обновления
* данные связанных задач Slurm
* числовое значение exit-кода

При создании задания метаданные образца и/или его результатов подаются на входную функцию шейпера пайплайна. Данная функция производит генерацию команды Nextflow для данного задания, а также словарей входных и выходных данных; кроме того, при необходимости генерируется TSV-файл для пайплайна Nextflow. Сгенерированная команда Nextflow затем подаётся на рендер стартового скрипта для системы Slurm.

После этого список сформированных заданий сортируется по указанному в их метаданных алгоритму и подаётся в Slurm в порядке очерёдности списка.

#### Завершение обработки

При завершении обработки запускается скрипт **db_filler.py**, запускающийся столько раз, сколько файлов должно быть спарсено для получения всего объёма результатов. Первый запуск скрипта осуществляется с аргумент(ом/ами) --set вида "basecalling_ubam:ubam_filepath". Аргумент set добавляет эту пару в результирующий YAML.

После парсинга всех файлов в коллекцию результатов БД вносятся данные из результирующего YAML, которые указаны в конфиге пайплайна.

## Завершение работы

### Сигналы завершения работы

# csp_nanopore_workflows

 Workflows for processing Nanopore reads with Nextflow implementation

#### to_do

Доработать обновление системных настроек в случае изменения конфига

align:
    samtools_index: -@ 4 -> -@ params.threads

каждое задание имеет свою отдельную входную (касается nxf, который должен выполняться в отдельной папке) и выходную директорию

рестарт дропнутых заданий
